//
// A short-scale tenor guitar for 3d printing.
//

import "constants.s3d" as constants
import "shapes.s3d" as shapes

// Constants for the proportions of the guitar.

// Body:
//  - the body is roughly teardrop shaped, formed from two cylinders.
//    The smaller cylinder is 2/5ths the radius of the larger.
let body_large_cylinder_radius = 100.0
let body_thickness = 60.0
let body_x_stretch = 1.3 
let body_y_stretch = 1.0 
let body_z_stretch = 1.0

// Total body size is approximately 28 centimeters, or 11 inches.
// The bridge sits 4 inches down the body from the end of the neck.
let bridge_to_neck = 5.0 * constants::inch_mm


// Neck sizing.
let scale_length = 18.0 * constants::inch_mm
let trussrod_length = 12.25 * constants::inch_mm
let trussrod_barrel_width = 3.0 / 8.0 * constants::inch_mm
let trussrod_barrel_depth = 10.6
let trussrod_barrel_length = 2.25 * constants::inch_mm
let trussrod_width = 0.25 * constants::inch_mm
let trussrod_depth = 9.1

let neck_length = scale_length - bridge_to_neck
let neck_width = 35.0
let tuning_peg_radius = 5.0

let tuning_peg_shim = cylinder(2.0, tuning_peg_radius + 3.0, tuning_peg_radius + 3.0) -
      cylinder(2.0, tuning_peg_radius, tuning_peg_radius)


// General utility function that divides a solid in half
// along the y axis. This doesn't quite work yet.
fun half(shape: Solid): Solid {
   let bounds = shape->bounds()
   let elev = (bounds->high()->z() - bounds->low()->z()) / 2.0

   shape->split_by_plane(v3(1.0, 0.0, 0.0), 0.0)[0] 
}



// The body of the guitar.
// The main body shape is formed from the hull of two cylinders.
fun body(width: Float, thickness: Float, solid: Boolean): Solid {
    fun base_shape(width: Float, thickness: Float): Solid {
        (cylinder(thickness, width, width * 3.0 / 4.0)
             ->scale(body_x_stretch, body_y_stretch, body_z_stretch) +
         cylinder(thickness, width/2.0, width/2.0)
             ->move(width, 0.0, 0.0)
        )->hull()
    }

    fun bracing(brace_length: Float, brace_width: Float, brace_height: Float): Solid {
        // The top has a brace running the same direction as the neck (the long brace),
        // and a perpendicular brace running across the body (the short brace).
        // The short brace has a slot where you can insert a carbon  fiber rod
        // to reinforce the body for metal strings; the brace can be left out if
        // you're using nylon strings.
        // Each of the braces is rectangular for most of the length, ending
        // with triangles that blend into the top at the edges.

        let long_brace_slot = cuboid(brace_length, brace_width, brace_height)
        let long_brace = long_brace_slot->scale(1.0, 1.5, 1.5)
        let long_brace_cap = shapes::wedge(brace_height*3.0, 
                                           brace_height * 1.5,
                                           brace_width * 1.5)
                                 ->rotate(-90.0, 180.0, 0.0)
        let brace_offset = (11.0 / 16.0) * brace_length
        let left_cap = long_brace_cap->move(brace_offset, 
                                            -brace_width/2.0 - 1.0, 
                                            -brace_height*0.75)
        let right_cap = long_brace_cap
                            ->rotate(0.0, 0.0, 180.0)
                            ->move(-brace_offset, 
                                   brace_width/2.0 + 1.0, 
                                   -brace_height*0.75)
        let capped_long_brace = (long_brace + left_cap + right_cap)
                                    ->move(0.0, 0.0, -30.0)
        let short_brace_block = cuboid(brace_width, width, brace_height)
        let short_brace_cap = shapes::wedge(brace_height, 2.0 * brace_height, brace_width)
        let short_brace = short_brace_block +
            short_brace_cap->rotate(-90.0, 90.0, -90.0)
                ->move(-brace_width/2.0, width/2.0, brace_height/2.0) +
            short_brace_cap->rotate(-90.0, 90.0, 90.0)
                ->move(brace_width/2.0, -width/2.0, brace_height/2.0)

        capped_long_brace 
          + short_brace->move(0.0, 0.0, -thickness/2.0 - 3.0) 
          - long_brace_slot->move(0.0, 0.0, -30.0)
    }

    fun tailpiece(width: Float, length: Float, thickness: Float): Solid {
       let pin = cylinder(thickness*3.0, 1.0, 1.0)
       let big = cuboid(1.0, width, thickness)
       let smaller = cuboid(1.0, width*0.8, thickness)->move(-length, 0.0, 0.0)
       let prism = (big + smaller)->hull()
            - pin->move(-length*0.85, width/2.0 * 0.2, 10.0)
            - pin->move(-length*0.85, width/2.0 * 0.6, 10.0)
            - pin->move(-length*0.85, -width/2.0 * 0.2, 10.0)
            - pin->move(-length*0.85, -width/2.0 * 0.6, 10.0)
            - pin->move(-length, width/2.0 * 0.2, 10.0)
            - pin->move(-length, width/2.0 * 0.6, 10.0)
            - pin->move(-length, -width/2.0 * 0.2, 10.0)
            - pin->move(-length, -width/2.0 * 0.6, 10.0)
    }

    // For attaching the neck, we'll be adding a screwblock. This generates the
    // screw holes and nut-slots in the screwblock for the body.
    fun nutslot(outer_size: Float, thickness: Float): Solid {
        shapes::hexagon(constants::m4_caphead_radius, 8.0)
            ->rotate(0.0, 90.0, 0.0) 
          + cylinder(200.0, constants::m4_radius, constants::m4_radius)
                ->rotate(0.0, 90.0, 0.0)
                ->move(200.0, 0.0, 0.0)
    }

    let shape = base_shape(width, thickness)
    let compound = shape + 
                  shape
                      ->scale(0.9, 0.9, 1.0)
                      ->move(0.0, 0.0, -thickness * 0.1)
    let outer = compound->hull()
    let inner = outer
                    ->scale(0.9, 0.9, 0.9)
                    ->move(0.0, 0.0, -thickness*0.1 + 1.0)
    let sound_hole: Solid =
         cylinder(thickness, width/5.0, width/5.0)
             ->scale(1.5, 1, 1.0)
             ->move(width/3.0, -width/2.0 , -thickness/2.0)
    let screwblock = cuboid(20.0, 70.0, 62.0)
    let pin = cylinder(20, 1.0, 1.0)
                  ->rotate(0.0,90.0,0.0)
                  ->move(35.0, 0.0, -10.0)
    let length = 25.0 
    let guideplate = (
            cuboid(5.0, neck_width, 15.0) 
            - pin->move(-length*0.85, neck_width/2.0 * 0.2, 7.0)
            - pin->move(-length*0.85, neck_width/2.0 * 0.6, 7.0)
            - pin->move(-length*0.85, -neck_width/2.0 * 0.2, 7.0)
            - pin->move(-length*0.85, -neck_width/2.0 * 0.6, 7.0)
            )->rotate(0.0, 45.0, 0.0)
             ->move(-120.0, 0.0, -65.0)

    if (solid) {
        outer + tailpiece(neck_width, 25.0, 10.0)->move(-width - 10.0, 0.0, -50.0)
    } else {
      outer 
      - inner 
      - sound_hole 
      + bracing(160.0, 3.5, 10.0)->move(-5.0, 0.0, -28.0)
      + tailpiece(neck_width, 25.0, 10.0)->move(-width - 10.0, 0.0, -50.0)
      + screwblock->move(105.0, 0.0, -35.0)
      - nutslot(4.0, 2.0)->move(90.0, 0.0, -20.0)
      - nutslot(4.0, 2.0)->move(90.0, 0.0, -40.0)
      + guideplate
    }
}

// the neck of the guitar.
fun neck(scale: Float, bridge_to_neck: Float, width: Float): Solid {
    // The shape of the headstock is two overlapping octagons, plus a rectangular
    // extension to move the headstock away from the neck, plus a cylinder
    // to smooth the joint from the headstock to the neck.

    fun make_headstock(width: Float, thickness: Float): Solid {
        let o = shapes::oct(width*0.8, thickness)
        let octagons = o + o->move(width * 0.70, 0.0, 0.0)
        let ext = cuboid(width, width /2.0, thickness * 0.8)
        let cylindrical_wedge = half(cylinder(width/4.0, width/4.0, width/4.0))
                                    ->scale(0.6, 1.0, 1.0)
                                    ->rotate(0.0, 90.0, 180.0)
                                    ->move(-80.0, 0.0, 10.0)
        let tuning_peg_hole = cylinder(30.0, tuning_peg_radius)->up(20.0)

        octagons->move(-width/2.5, 0.0, 0.0)
            + (ext->move(-width/2.0, 0.0, thickness/2.0) + cylindrical_wedge)->hull()
            - tuning_peg_hole->right(width*0.30)->forward(width*0.18)
            - tuning_peg_hole->right(width*0.30)->forward(-width*0.18)
            - tuning_peg_hole->right(-width*0.4)->forward(width*0.18)
            - tuning_peg_hole->right(-width*0.4)->forward(-width*0.18)
            - shapes::mark(width/6.0, thickness/4.0)->move(0.0, 0.0, 12.0)->rotate(0.0, 0.0, -90.0)
    }


    // For the neck heel: we want a basic shape which is a half cylinder + a rectangle.
    //
    //   +-------+--
    //   |       |  \
    //   |       |   |
    //   |       |  /
    //   +-------+--
    //
    // We want an extrusion of that shape that grows larger towards the fingerboard.
    fun make_heel(radius: Float, length: Float, thickness: Float): Solid {
        let shape: Solid = cylinder(1.0, radius, radius)->move(-radius, 0.0, 0.0) +
            cuboid(radius * 2.0, radius*2.0, 1.0)
        let bridge_to_neck = length / 4.0
        let result = (shape->scale(2.0, 1.5, 1.0)
                         ->move(-bridge_to_neck, 0.0, thickness) + shape)
                         ->hull()
                         ->rotate(90.0, 0.0, -90.0)
        let screwhole = (cylinder(80.0, constants::m4_radius) 
                        + cylinder(25.0, constants::m4_caphead_radius)
                        )->rotx(-90)
        result - screwhole->move(-10.0, 40.0, 0.0) 
               - screwhole->move(-30.0, 60.0, 0.0)
    }

    // the trussrod cutout is a long slot cut into the neck for (obviously) the trussrod.
    // At the head-end of the neck, it needs to get a little wider and deeper in order 
    // to accomodate the hardware at the top end of the rod.
    fun trussrod_cutout(length: Float): Solid {
        let main_slot = cuboid(length*1.2, trussrod_depth + 1.0, trussrod_width)
        let barrel = cuboid(trussrod_barrel_length, trussrod_barrel_depth, trussrod_barrel_width)
            ->move((length *1.2 - trussrod_barrel_length)/2.0 
                     - (length - trussrod_barrel_length), 
                   -(trussrod_barrel_depth - trussrod_depth)/2.0 + 1.0,
                   0.0)
        let slot = (main_slot + barrel)
                       ->move(length/2.0 * 1.2, trussrod_depth/2.0, -trussrod_width/2.0)
        slot->rotate(0.0, 90.0, -90.0)
    }

     let length = scale - bridge_to_neck
     let main =  half(cylinder(length + 20, width/2.0, width/2.0)->scale(0.7, 1.0, 1.0))
     let head =  make_headstock(width*2.0, width/3.0)
         ->rotate(0.0, -71.0, 0.0)
         ->move(32.0, 0.0, length/4.0 -12.0)
     let heel = make_heel(width/3.0, 50.0, 70.0)
     main + head + heel->rotate(90.0, 0.0, 0.0)->move(70.0, 0.0, -(length+25.0))
          - trussrod_cutout(trussrod_length)->move(0.5, -trussrod_width / 2.0, 48.0)
}

// Several different parts need to have notches cut into them for the strings so 
// that they can seat the strings in the right position. The notch is shaped as 
// a triangular prism.
let notch = triangle(2.0, 4.0)
                 ->extrude(100.0, 4)
                 ->rotz(90.0)
                 ->roty(90.0)
                 ->down(2.5)
            - cuboid(100.0, 2.0, 4.00)->move(50.0, 0.0, 1.0)



fun fretboard(length: Float, width: Float): Solid {
    fun fret_position(scale: Float, fret: Float): Float {
        let c = 2.0^(1.0/12.0)
        scale / c^fret
    }

    fun fret_distance(scale: Float, fret: Float): Float {
        fret_position(scale, fret-1) - fret_position(scale, fret)
    }

    fun fret(scale: Float, fret: Float): Solid {
        cuboid(width, 2.0, 0.75)
            ->move(0.0,  
                   1.5, 
                   fret_position(scale, fret) - length/2.0 - bridge_to_neck)
    }

    fun nut(width: Float, height: Float, thickness: Float): Solid {
       let sslot = notch->rotate(180.0, 0.0, 90.0)
                        ->forward(150.0)
                        ->down(10.0)
        let large = cuboid(width, thickness/2.0, 1.0)
        let small = cuboid(width, thickness/4.0, 1.0)
                      ->move(0.0, -thickness/8.0, height)
        let full = large + small
        let slot =  cylinder(thickness, 0.5, 0.5)
                        ->rotate(0.0, 90.0, 90.0)
                        ->move(0.0, 200.0, height)
        let string_sep = width / 4.0
        let edge = string_sep / 2.0
        full->hull()->move(0.0, 200.0, 0.0)
           - sslot->move(-width/2.0 + edge, 0.0, 16.0)
           - sslot->move(-width/2.0 + edge + string_sep, 0.0, 16.0)
           - sslot->move(-width/2.0 + edge + 2.0 *  string_sep, 0.0, 16.0)
           - sslot->move(-width/2.0 + edge + 3.0 *  string_sep, 0.0, 16.0)
    }

    // dotpos computes the position of the dot inlays along the fretboard. It 
    // takes the fret number of the fret immediately after the dot.
    fun dotpos(fret: Int): Float {
        let below = fret_position(scale_length, (fret - 1)->float())
        let above = fret_position(scale_length, fret->float())
        0.5 * (above + below) - length/2.0 - bridge_to_neck
    }

    fun single_dot(fret: Int): Solid {
        dot->move(0.0, 1.0, dotpos(fret))
    }

    fun side_dot(fret: Int): Solid {
        cylinder(30.0, 1.75/2.0, 1.75/2.0)
            ->rotate(0.0, -90.0, 0.0)
            ->move(0.0, 0.0, dotpos(fret))
    }

    fun double_side_dot(fret: Int): Solid {
        let pos = dotpos(fret)
        cylinder(30.0, 1.75/2.0, 1.75/2.0)
            ->rotate(0.0, -90.0, 0.0)
            ->move(0.0, 0.0, pos + 2) +
          cylinder(30.0, 1.75/2.0, 1.75/2.0)
              ->rotate(0.0, -90.0, 0.0)
              ->move(0.0, 0.0, pos - 2)
    }

    fun double_dot(fret: Int): Solid {
        let pos = dotpos(fret)
        dot->move(-6.0, 1.0, pos) + dot->move(6.0, 1.0, pos)
    }

    let dot = cylinder(5.0, 2.0, 2.0)->rotate(90.0, 0.0, 0.0)
    let frets = union(for f in 1->to(20) {
            fret(scale_length, f)
        })
    let board = cuboid(width, 5.0, length+10.0)
        // frets
        - frets
        - union(for d in [3, 5, 7, 10] {
            single_dot(d) + side_dot(d)
          })
        - double_dot(12)
        - double_side_dot(12)
        + nut(width, 8.0, 10.0)
              ->rotate(90.0, 0.0, 180.0)
              ->down(27.5)
              ->backward(2.0)
     board->move(0.0, 20.0, -20.0)
}

// generate an alignment slot to take a piece of 1.75mm filament for assembly.
let aligner = cylinder(20.0, 0.875, 0.875)->roty(90.0)


// If the neck is split into two pieces, it's still just a little
// too large for my printers. So it's split into three sections.
let full_neck = neck(scale_length, bridge_to_neck, neck_width)->rotate(0.0, -90.0, 90.0)

let neckpeg = cylinder(4.0,  2.0, 2.0)->up(2.0)

let full_fretboard = fretboard(scale_length - bridge_to_neck, neck_width)
                         ->rotx(-90.0)
                         ->rotz(-90.0)
                         ->move(325.0, 0.0, -63.0)
   - neckpeg->move(320.0, 10.0, -80.0)
   - neckpeg->move(320.0, -10.0, -80.0)
   - neckpeg->move(440.0, 10.0, -80.0)
   - neckpeg->move(440.0, -10.0, -80.0)
   - neckpeg->move(200.0, 10.0, -80.0)
   - neckpeg->move(200.0, -10.0, -80.0)

let pegged_neck = neck(scale_length, bridge_to_neck, neck_width)
                      ->rotate(0.0, -90.0, 180.0)
                      ->move(500.0, 0.0, -80.0)
   - neckpeg->move(320.0, 10.0, -80.0)
   - neckpeg->move(320.0, -10.0, -80.0)
   - neckpeg->move(440.0, 10.0, -80.0)
   - neckpeg->move(440.0, -10.0, -80.0)
   - neckpeg->move(200.0, 10.0, -80.0)
   - neckpeg->move(200.0, -10.0, -80.0)

// neck runs from approx x=130 to x=600 - so let's say 500mm long.
// so pieces should be ~160mm.
let neck_split_a = pegged_neck->split_by_plane(v3(1.0, 0.0, 1.0),    160.0 * 1.414)
let neck_split_b = neck_split_a[1]->split_by_plane(v3(-1.0, 0.0, 1.0), -250.0)

produce("fretboard-full") {
    pegged_neck + full_fretboard
}

produce("neck-a") {
     neck_split_a[0]
     - aligner->move(405.0, 10.0, -75.0)
     - aligner->move(395.0, -10.0, -75.0)
}

produce("neck-b") {
    neck_split_b[1]
    - aligner->move(405.0, 10.0, -75.0)
    - aligner->move(395.0, -10.0, -75.0)
    - aligner->move(288.0, 10.0, -75.0)
    - aligner->move(288.0, -10.0, -75.0)
}

produce("neck-c") {
    neck_split_b[0]
    - aligner->move(288.0, 10.0, -75.0)
    - aligner->move(288.0, -10.0, -75.0)
}


let fretboard_parts = full_fretboard->split_by_plane(v3(1.0, 0.0, 0.0), 325.0)

produce("fretboard-a") {
    fretboard_parts[0]
   - aligner->move(335.0, -15.0, -83.0)
   - aligner->move(335.0, 15.0, -83.0)
}

produce("fretboard-b") {
    fretboard_parts[1]
    - aligner->move(335.0, -15.0, -83.0)
    - aligner->move(335.0, 15.0, -83.0)
}


let full_body = body(body_large_cylinder_radius, body_thickness, false)
let necked_body = full_body -
    neck(scale_length, bridge_to_neck, neck_width)->rotate(0.0, -90.0, 180.0)->move(482.0, 0.0, -80.0)


let split_body_parts = necked_body->split_by_plane(v3(-1.0, 0.0, 1.0), -16.8)

fun triple_split_body(body: Solid): [Solid] {
    let tail_split = body->split_by_plane(v3(-1.0, 0.0, 1.0), 0.0)
    let head_and_center = tail_split[1]->split_by_plane(v3(1.0, 0.0, 1.0), 20.0)
    let tail = tail_split[0]
       - cuboid(20.0, 100.0, 2.0)->move(0.0, 0.0, -4.0)
        - cuboid(20.0, 30.0, 2.0)->move(-60.0, -30.0, -64.0)
        - cuboid(20.0, 30.0, 2.0)->move(-60.0, 30.0, -64.0)

    let head = head_and_center[0]
        - cuboid(20.0, 100.0, 2.0)->move(30.0, 0.0, -4.0)
        - cuboid(20.0, 100.0, 2.0)->move(93.0, 0.0, -64.0)


    let center = head_and_center[1]
        - cuboid(20.0, 100.0, 2.0)->move(0.0, 0.0, -4.0)
        - cuboid(20.0, 30.0, 2.0)->move(-60.0, -30.0, -64.0)
        - cuboid(20.0, 30.0, 2.0)->move(-60.0, 30.0, -64.0)

        - cuboid(20.0, 100.0, 2.0)->move(30.0, 0.0, -4.0)
        - cuboid(20.0, 100.0, 2.0)->move(93.0, 0.0, -64.0)

   [tail, center, head]
}

let body_parts = triple_split_body(necked_body)

produce("body-tail") {
    body_parts[0]
}

produce("body-center") {
    body_parts[1]
}

produce("body-neck") {
    body_parts[2]
}

produce("assembled") {
    full_body
     + neck(scale_length, bridge_to_neck, neck_width)
           ->rotate(0.0, -90.0, 180.0)
           ->move(500.0, 0.0, -80.0)
     + full_fretboard

}

fun stand(): Solid {
   // make a solid copy of the body, to use to form a cutout in the stand.
   let full_body = body(body_large_cylinder_radius, body_thickness, true)

   // the stand starts with the top half a cylinder minus a smaller cylinder. We 
   // cut the sides to make it look like it has legs; and then we cut off the front and back 
   // to give it pleasant looking asymmetrical angles.
   let c = cylinder(200.0, 200.0, 200.0)
    c->split_by_plane(v3(1.0, 0.0, 0.0), 0.0)[0] - full_body->scale(v3(1.1, 1.1, 1.1))->rotx(180.0)->roty(20.0)->down(150.0)->right(200.0) -
      cuboid(100.0, 400.0, 400.0 )->roty(110.0)->up(50.0)->right(30.0) -
      cuboid(100.0, 400.0, 400.0)->roty(80.0)->down(250.0)->right(40.0)
      - cylinder(400.0, 100.0, 100.0)
      - cylinder(400.0, 70.0, 70.0)->scale(v3(1.5, 1.0, 1.0))->rotx(90.0)->down(100.0)->backward(200.0)
      - cuboid(100.0, 400.0, 400.0)->rotz(90.0)->forward(170.0)
      - cuboid(100.0, 400.0, 400.0)->rotz(90.0)->backward(170.0)

        // Next we cut out a bunch of cylinders. These have no real purpose,
        // except that they look nice, and they reduce the amount of filament 
        // needed to print the stand.

      - cylinder(400.0, 20.0, 20.0)->backward(80.0)->right(100.0)
      - cylinder(400.0, 20.0, 20.0)->forward(80.0)->right(100.0)
      - cylinder(400.0, 10.0, 10.0)->backward(100.0)->right(140.0)
      - cylinder(400.0, 10.0, 10.0)->forward(100.0)->right(140.0)
      - cylinder(400.0, 20.0, 20.0)->forward(40.0)->right(140.0)
      - cylinder(400.0, 20.0, 20.0)->backward(40.0)->right(140.0)
      - cylinder(400.0, 10.0, 10.0)->rotx(90.0)->backward(200.0)->right(100.0)->down(45.0)
      - cylinder(400.0, 10.0, 10.0)->rotx(90.0)->backward(200.0)->right(100.0)->down(160.0)
      - cylinder(400.0, 10.0, 10.0)->rotx(90.0)->backward(200.0)->right(60.0)->down(28.0)
      - cylinder(400.0, 10.0, 10.0)->rotx(90.0)->backward(200.0)->right(60.0)->down(180.0)
      - cylinder(400.0, 10.0, 10.0)->rotx(90.0)->backward(200.0)->right(130.0)->down(65.0)
      - cylinder(400.0, 10.0, 10.0)->rotx(90.0)->backward(200.0)->right(130.0)->down(160.0)
      - cylinder(400.0, 20.0, 20.0)->rotx(90.0)->backward(200.0)->right(130.0)->down(112.5)
      - cylinder(400.0, 10.0, 10.0)->backward(105.0)->right(40.0)
      - cylinder(400.0, 10.0, 10.0)->forward(105.0)->right(40.0)

      // and finally, we cut a slot in the front of the stand to make room for 
      // the strings when the guitar is sitting in it.
      - cuboid(200.0, 60.0, 35.0)->rotx(90.0)->right(130.0)->down(50.0)
      - cylinder(100.0, 40.0, 40.0)->right(200.0)

      + shapes::mark(10.0, 2.0)->rotz(-90.0)->forward(110.0)->right(10.0)
 }

produce("stand") {
    stand()
  }

fun make_bridge(width: Float, height: Float): Solid {
    let br = shapes::prism(2.0, width, height, 3.0, 1.2)
    let cutout = shapes::prism(4.0, width * 0.3, height * 0.8,
         3.0, 1.4)
    let support = shapes::prism(20.0, 2.0, 0.25*height,
         0.3, 0.3)->roty(180.0)->up(height)
    let offset = width / 5.0
    let far_left = -0.5 * width

    br - shapes::mark(5.0, 2.0)
             ->rotx(-90.0)
             ->rotz(90.0)
             ->left(1.0)
             ->up(5.0)
       - cutout->up(0.3 * height)->forward(0.25 * width)
       - cutout
             ->up(0.3 * height)
             ->backward(0.25 * width) 
       + support
       + support->forward(0.5 * width)
       + support->backward(0.5 * width)
       - notch->move(-4.0, far_left + offset,  2.0)
       - notch->move(-4.0, far_left + 2.0 * offset, 2.0)
       - notch->move(-4.0, far_left + 3.0 * offset, 2.0)
       - notch->move(-4.0, far_left + 4.0  * offset, 2.0)
}

produce("bridge") {
  make_bridge(neck_width*1.4, 20.0)->down(20.0)
  make_bridge(neck_width*1.4, 19.0)->down(19.0)->left(40.0)
  make_bridge(neck_width*1.4, 18.0)->down(18.0)->right(40.0)
}

let dot = cylinder(2, 2, 2)->left(20.0)
let neck_aligner = cylinder(4, 2, 2)->left(20.0)

produce("misc_bits") {
  dot
  dot->forward(10.0)
  dot->forward(20.0)
  dot->forward(30.0)
  dot->forward(40.0)
  dot->forward(50.0)
  dot->forward(60.0)
  dot->forward(70.0)
  dot->forward(80.0)
  dot->forward(90.0)
  dot->forward(100.0)
  neck_aligner->forward(110.0)
  neck_aligner->forward(110.0)->left(10.0)
  neck_aligner->forward(110.0)->left(20.0)
  neck_aligner->forward(110.0)->left(30.0)
  neck_aligner->forward(110.0)->left(40.0)
  neck_aligner->forward(110.0)->left(50.0)
  neck_aligner->forward(110.0)->left(60.0)
  neck_aligner->forward(110.0)->left(70.0)
  neck_aligner->forward(110.0)->left(80.0)

   tuning_peg_shim->right(0.0)
   tuning_peg_shim->move(20.0, 0.0, 0.0)->right(0.0)
   tuning_peg_shim->move(40.0, 0.0, 0.0)->right(0.0)
   tuning_peg_shim->move(0.0, 20.0, 0.0)->right(0.0)
   tuning_peg_shim->move(20.0, 20.0, 0.0)->right(0.0)
   tuning_peg_shim->move(40.0, 20.0, 0.0)->right(0.0)

  cuboid(20.0, 100.0, 2.0)->left(40.0)->forward(50.0)
  cuboid(20.0, 100.0, 2.0)->left(70.0)->forward(50.0)
  cuboid(20.0, 100.0, 2.0)->left(100.0)->forward(50.0)
  cuboid(20.0, 30.0, 2.0)->move(0.0, 50.0, 0.0)
  cuboid(20.0, 30.0, 2.0)->move(40.0, 50.0, 0.0)
  cuboid(20.0, 30.0, 2.0)->move(0.0, 90.0, 0.0)
  cuboid(20.0, 30.0, 2.0)->move(40.0, 90.0, 0.0)
}
